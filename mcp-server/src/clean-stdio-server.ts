/**
 * TRUE AI Code Generation MCP Server - Claude Desktop Integration
 * Claude generates complete React/Remotion code - MCP server executes it
 * NO TEMPLATES - Pure AI-powered code generation and execution
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration - Standardized to 6970/6971 ports
const APP_ROOT = process.env.DOCKER_CONTAINER === 'true' ? '/app' : path.resolve(__dirname, '../..');
const EXPORTS_DIR = process.env.DOCKER_CONTAINER === 'true' ? '/workspace/out' : path.join(APP_ROOT, 'clean-cut-exports');
const SRC_DIR = process.env.DOCKER_CONTAINER === 'true' ? '/workspace/src' : path.join(APP_ROOT, 'clean-cut-components');
const STUDIO_PORT = parseInt(process.env.REMOTION_STUDIO_PORT || '6970');

// Safe stderr-only logging (no stdout pollution for STDIO)
const log = (level: string, message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  console.error(`[${timestamp}] [CLEAN-STDIO] ${message}`);
  if (data) {
    console.error(JSON.stringify(data, null, 2));
  }
};

class TrueAiStdioMcpServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: 'clean-cut-mcp',
        version: '2.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  private setupErrorHandling(): void {
    this.server.onerror = (error) => {
      log('error', 'MCP Server error', { error: error.message });
    };

    process.on('SIGINT', async () => {
      log('info', 'Shutting down gracefully...');
      await this.server.close();
      process.exit(0);
    });
  }

  private setupToolHandlers(): void {
    // TRUE AI TOOLS: Claude generates code - MCP server executes it
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'create_animation',
            description: 'Execute Claude-generated React/Remotion animation code - creates component file',
            inputSchema: {
              type: 'object',
              properties: {
                code: {
                  type: 'string',
                  description: 'Complete React/Remotion TypeScript code generated by Claude'
                },
                componentName: {
                  type: 'string',
                  description: 'React component name (e.g. "RisingSun", "ParticleSystem")'
                },
                duration: {
                  type: 'number',
                  default: 8,
                  description: 'Animation duration in seconds'
                }
              },
              required: ['code', 'componentName']
            }
          },
          {
            name: 'update_composition',
            description: 'Register new animation component in Remotion Root.tsx',
            inputSchema: {
              type: 'object',
              properties: {
                componentName: {
                  type: 'string',
                  description: 'Component name to register'
                },
                duration: {
                  type: 'number',
                  description: 'Duration in seconds'
                }
              },
              required: ['componentName', 'duration']
            }
          },
          {
            name: 'get_studio_url',
            description: 'Get the URL for Remotion Studio interface',
            inputSchema: {
              type: 'object',
              properties: {},
              additionalProperties: false
            }
          },
          {
            name: 'get_export_directory',
            description: 'Get information about persistent video export directory',
            inputSchema: {
              type: 'object',
              properties: {},
              additionalProperties: false
            }
          },
          {
            name: 'list_existing_components',
            description: 'List all existing animation components to avoid naming conflicts',
            inputSchema: {
              type: 'object',
              properties: {},
              additionalProperties: false
            }
          },
          {
            name: 'get_project_guidelines', 
            description: 'Get project configuration and naming guidelines for animations',
            inputSchema: {
              type: 'object',
              properties: {},
              additionalProperties: false
            }
          }
        ]
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        if (name === 'create_animation') {
          return await this.handleCreateAnimation(args);
        } else if (name === 'update_composition') {
          return await this.handleUpdateComposition(args);
        } else if (name === 'get_studio_url') {
          return await this.handleGetStudioUrl();
        } else if (name === 'get_export_directory') {
          return await this.handleGetExportDirectory();
        } else if (name === 'list_existing_components') {
          return await this.handleListExistingComponents();
        } else if (name === 'get_project_guidelines') {
          return await this.handleGetProjectGuidelines();  
        } else {
          throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        log('error', `Tool ${name} failed`, { error: error.message });
        return {
          content: [{
            type: 'text',
            text: `[ERROR] ${name} failed: ${error instanceof Error ? error.message : String(error)}`
          }],
          isError: true
        };
      }
    });
  }

  private validateAndFixInterpolate(code: string): string {
    // Pattern to detect interpolate calls with potential issues
    const interpolatePattern = /interpolate\s*\(\s*([^,]+),\s*\[([^\]]+)\],\s*\[([^\]]+)\]/g;

    let hasUnsafeInterpolate = false;
    let matches;

    // Check for descending inputRange arrays
    while ((matches = interpolatePattern.exec(code)) !== null) {
      const inputRangeStr = matches[2];
      const numbers = inputRangeStr.split(',').map(s => {
        const trimmed = s.trim();
        // Handle expressions like "height - 100", "height / 2"
        if (trimmed.includes('height')) {
          if (trimmed.includes('- 100')) return 980; // height - 100 = 980
          if (trimmed.includes('/ 2')) return 540;   // height / 2 = 540
          return 1080; // just height = 1080
        }
        return parseFloat(trimmed) || 0;
      });

      // Check if array is descending (monotonic violation)
      for (let i = 1; i < numbers.length; i++) {
        if (numbers[i] <= numbers[i-1]) {
          hasUnsafeInterpolate = true;
          break;
        }
      }
    }

    if (!hasUnsafeInterpolate) {
      return code; // No issues found
    }

    // Add safeInterpolate helper function at the top of component
    const safeInterpolateFunction = `
  // Safe interpolation helper - prevents inputRange monotonic errors
  const safeInterpolate = (frame, inputRange, outputRange, easing) => {
    const [inputStart, inputEnd] = inputRange;
    const [outputStart, outputEnd] = outputRange;
    if (inputEnd === inputStart) return outputStart;
    if (frame <= inputStart) return outputStart;
    if (frame >= inputEnd) return outputEnd;
    return interpolate(frame, inputRange, outputRange, { easing });
  };
`;

    // Insert safeInterpolate function after imports and before component body
    const insertAfterImports = code.replace(
      /(import\s+.*from\s+['"][^'"]+['"];?\s*\n)+/,
      '$&\n' + safeInterpolateFunction
    );

    // Replace unsafe interpolate calls with safeInterpolate
    const safeCode = insertAfterImports.replace(/\binterpolate\s*\(/g, 'safeInterpolate(');

    return safeCode;
  }

  private async handleCreateAnimation(args: any) {
    const { code, componentName, duration = 8 } = args || {};

    log('info', 'Executing Claude-generated animation code', { componentName, duration });

    // Validate required parameters
    if (!code) {
      return {
        content: [{
          type: 'text',
          text: '[ERROR] code is required - Claude must provide complete React/Remotion code'
        }],
        isError: true
      };
    }
    
    if (!componentName) {
      return {
        content: [{
          type: 'text',
          text: '[ERROR] componentName is required - provide React component name'
        }],
        isError: true
      };
    }

    // Ensure directories exist
    await fs.mkdir(EXPORTS_DIR, { recursive: true });
    await fs.mkdir(SRC_DIR, { recursive: true });

    // Validate component name format
    const validComponentName = componentName.charAt(0).toUpperCase() + componentName.slice(1);
    const componentPath = path.join(SRC_DIR, `${validComponentName}.tsx`);
    
    // COLLISION DETECTION: Check if component already exists
    const componentExists = await fs.access(componentPath).then(() => true).catch(() => false);
    if (componentExists) {
      log('warn', `Component ${validComponentName} already exists - overwriting`, { componentPath });
    }
    
    // Write Claude's generated code with export pattern fix for Remotion compatibility
    // CRITICAL FIX: Convert 'export default ComponentName' to 'export { ComponentName }'
    const fixedCode = code.replace(
      new RegExp(`export\\s+default\\s+${validComponentName}\\s*;?`, 'g'),
      `export { ${validComponentName} };`
    );

    // INTERPOLATE VALIDATION: Detect and fix unsafe interpolate patterns
    const safeCode = this.validateAndFixInterpolate(fixedCode);

    await fs.writeFile(componentPath, safeCode);
    log('info', `Created animation file with Claude's code: ${componentPath}`);

    const overwriteWarning = componentExists ? `\\n[WARNING] Overwrote existing ${validComponentName} component` : '';
    
    return {
      content: [{
        type: 'text',
        text: `[ANIMATION CREATED] ${validComponentName}\\n\\n` +
              `[FILE] ${validComponentName}.tsx\\n` +
              `[DURATION] ${duration} seconds\\n` +
              `[STUDIO] Ready at http://localhost:${STUDIO_PORT}${overwriteWarning}\\n\\n` +
              `[SUCCESS] Claude's animation code executed successfully!`
      }]
    };
  }

  private async handleUpdateComposition(args: any) {
    const { componentName, duration = 8 } = args || {};

    log('info', 'Registering component in Root.tsx', { componentName, duration });

    if (!componentName) {
      return {
        content: [{
          type: 'text',
          text: '[ERROR] componentName is required'
        }],
        isError: true
      };
    }

    const validComponentName = componentName.charAt(0).toUpperCase() + componentName.slice(1);
    
    try {
      await this.updateRootTsx(validComponentName, duration);
      log('info', `Registered ${validComponentName} in Root.tsx`);
      
      return {
        content: [{
          type: 'text',
          text: `[COMPOSITION UPDATED] ${validComponentName}\\n\\n` +
                `[REGISTERED] Component added to Remotion Root.tsx\\n` +
                `[DURATION] ${duration} seconds\\n` +
                `[STUDIO] Available at http://localhost:${STUDIO_PORT}\\n\\n` +
                `[SUCCESS] Animation ready for preview!`
        }]
      };
    } catch (error) {
      log('error', 'Failed to update composition', error);
      return {
        content: [{
          type: 'text',
          text: `[ERROR] Failed to update composition: ${error instanceof Error ? error.message : String(error)}`
        }],
        isError: true
      };
    }
  }

  private async handleGetStudioUrl() {
    return {
      content: [{
        type: 'text',
        text: `[STUDIO] Remotion Studio is available at:\\n\\nhttp://localhost:${STUDIO_PORT}\\n\\nOpen this URL in your browser to access the visual editor for your animations.`
      }]
    };
  }
  
  private async handleGetExportDirectory() {
    const isDocker = process.env.DOCKER_CONTAINER === 'true';
    
    if (isDocker) {
      return {
        content: [{
          type: 'text',
          text: `[EXPORT DIRECTORY] Videos exported from Remotion Studio appear in:\\n\\n` +
                `Host Path: ./clean-cut-exports\\n` +
                `Container Path: /workspace/out\\n\\n` +
                `[HOW IT WORKS]\\n` +
                `- Export from Remotion Studio (http://localhost:${STUDIO_PORT})\\n` +
                `- Videos automatically appear in ./clean-cut-exports\\n` +
                `- Persistent storage across container restarts\\n` +
                `- Cross-platform (Windows, macOS, Linux)\\n\\n` +
                `[SUCCESS] Persistent video storage active!`
        }]
      };
    } else {
      return {
        content: [{
          type: 'text',
          text: `[EXPORT DIRECTORY] Videos are saved to:\\n\\n${EXPORTS_DIR}\\n\\n` +
                `Export from Remotion Studio and files will appear in the above directory.`
        }]
      };
    }
  }

  // REMOVED: All template fraud code - Claude Desktop generates ALL animation code using TRUE AI

  private async handleListExistingComponents() {
    try {
      const files = await fs.readdir(SRC_DIR);
      const componentFiles = files.filter(file => 
        file.endsWith('.tsx') && 
        file !== 'Composition.tsx' && 
        file !== 'Root.tsx' && 
        file !== 'index.ts'
      );
      
      const components = componentFiles.map(file => {
        const componentName = file.replace('.tsx', '');
        return { name: componentName, file: file };
      });
      
      return {
        content: [{
          type: 'text',
          text: `[EXISTING COMPONENTS] Found ${components.length} components:\\n\\n` +
                components.map(comp => `- ${comp.name} (${comp.file})`).join('\\n') + 
                '\\n\\n[TIP] Use unique names to avoid overwriting existing components!'
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `[ERROR] Could not list components: ${error instanceof Error ? error.message : String(error)}`
        }],
        isError: true
      };
    }
  }

  private async handleGetProjectGuidelines() {
    try {
      const guidelinesDir = path.join(APP_ROOT, 'claude-dev-guidelines');
      const advancedDir = path.join(guidelinesDir, 'ADVANCED');
      
      // Read all guideline files
      const configContent = await fs.readFile(path.join(guidelinesDir, 'PROJECT_CONFIG.md'), 'utf8');
      const readmeContent = await fs.readFile(path.join(guidelinesDir, 'README.md'), 'utf8');
      const animationPatternsContent = await fs.readFile(path.join(advancedDir, 'ANIMATION_PATTERNS.md'), 'utf8');
      const remotionRulesContent = await fs.readFile(path.join(advancedDir, 'REMOTION_ANIMATION_RULES.md'), 'utf8');
      const quickRefContent = await fs.readFile(path.join(advancedDir, 'QUICK_REFERENCE.md'), 'utf8');
      
      return {
        content: [{
          type: 'text',
          text: `[PROJECT GUIDELINES - COMPLETE]\\n\\n` +
                `=== PROJECT CONFIGURATION ===\\n${configContent}\\n\\n` +
                `=== PROJECT OVERVIEW ===\\n${readmeContent}\\n\\n` +
                `=== ANIMATION PATTERNS ===\\n${animationPatternsContent}\\n\\n` +
                `=== REMOTION RULES ===\\n${remotionRulesContent}\\n\\n` +
                `=== QUICK REFERENCE ===\\n${quickRefContent}\\n\\n` +
                `[NAMING CONVENTION]\\n` +
                `Use descriptive, unique component names like:\\n` +
                `- FloatingOrbs, ParticleExplosion, WaveMotion\\n` +
                `- SeedreamShowcase, ProductDemo, BrandIntro\\n` +
                `- Avoid generic names like Animation, Component, Video`
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `[ERROR] Could not read guidelines: ${error instanceof Error ? error.message : String(error)}`
        }],
        isError: true
      };
    }
  }

  // Update Root.tsx to register the new animation
  private async updateRootTsx(componentName: string, duration: number): Promise<void> {
    const rootPath = path.join(SRC_DIR, 'Root.tsx');
    const durationFrames = Math.floor(duration * 30);
    
    try {
      let rootContent = '';
      
      // Check if Root.tsx exists
      const rootExists = await fs.access(rootPath).then(() => true).catch(() => false);
      
      if (!rootExists) {
        // Create new Root.tsx
        rootContent = `import { Composition } from 'remotion';
import { ${componentName} } from './${componentName}';

export const RemotionRoot: React.FC = () => {
  return (
    <>
      <Composition
        id="${componentName}"
        component={${componentName}}
        durationInFrames={${durationFrames}}
        fps={30}
        width={1920}
        height={1080}
      />
    </>
  );
};`;
      } else {
        // Read existing Root.tsx and rebuild it properly
        const existingContent = await fs.readFile(rootPath, 'utf8');
        
        // Extract existing imports and compositions
        const importLines: string[] = [];
        const compositions: Array<{id: string, component: string, duration: number}> = [];
        
        const lines = existingContent.split('\n');
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith('import { ') && trimmed.includes("} from './") && !trimmed.includes('./Composition')) {
            // Extract component name from import (exclude the base Composition)
            const match = trimmed.match(/import { (\\w+) } from/);
            if (match) {
              importLines.push(trimmed);
            }
          } else if (trimmed.includes('id="') && !trimmed.includes('id="Main"')) {
            // Extract composition info
            const idMatch = trimmed.match(/id="(\\w+)"/);
            const componentMatch = trimmed.match(/component={(\\w+)}/);
            const durationMatch = trimmed.match(/durationInFrames={(\\d+)}/);
            if (idMatch && componentMatch && durationMatch) {
              compositions.push({
                id: idMatch[1],
                component: componentMatch[1],
                duration: parseInt(durationMatch[1])
              });
            }
          }
        }
        
        // Add new component if not already present
        const importStatement = `import { ${componentName} } from './${componentName}';`;
        if (!importLines.includes(importStatement)) {
          importLines.push(importStatement);
        }
        
        // Add new composition if not already present
        if (!compositions.find(comp => comp.id === componentName)) {
          compositions.push({
            id: componentName,
            component: componentName,
            duration: durationFrames
          });
        }
        
        // Rebuild Root.tsx with proper structure
        rootContent = `import { Composition } from 'remotion';
import { Comp } from './Composition';
${importLines.join('\\n')}

export const RemotionRoot: React.FC = () => {
  return (
    <>
      <Composition
        id="Main"
        component={Comp}
        durationInFrames={90}
        fps={30}
        width={1920}
        height={1080}
      />
${compositions.map(comp => `      <Composition
        id="${comp.id}"
        component={${comp.component}}
        durationInFrames={${comp.duration}}
        fps={30}
        width={1920}
        height={1080}
      />`).join('\\n')}
    </>
  );
};`;
      }
      
      await fs.writeFile(rootPath, rootContent);
      log('info', `Updated Root.tsx with ${componentName}`);
    } catch (error) {
      log('error', 'Failed to update Root.tsx', { error: error.message });
      throw error;
    }
  }

  async run(): Promise<void> {
    log('info', 'Starting TRUE AI STDIO MCP Server');
    log('info', `App Root: ${APP_ROOT}`);
    log('info', `Exports Directory: ${EXPORTS_DIR}`);
    log('info', `Source Directory: ${SRC_DIR}`);
    log('info', `Studio Port: ${STUDIO_PORT}`);
    
    // Ensure directories exist
    await fs.mkdir(EXPORTS_DIR, { recursive: true });
    await fs.mkdir(SRC_DIR, { recursive: true });

    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    
    log('info', 'TRUE AI STDIO MCP Server connected and ready!');
    log('info', 'Available tools: create_animation, update_composition, get_studio_url, get_export_directory, list_existing_components, get_project_guidelines');
    log('info', 'Claude Desktop can now generate ANY animation using TRUE AI!');
  }
}

// Start the TRUE AI server
const server = new TrueAiStdioMcpServer();
server.run().catch((error) => {
  console.error('Failed to start TRUE AI STDIO MCP Server:', error);
  process.exit(1);
});
