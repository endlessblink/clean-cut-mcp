/**
 * TRUE AI Code Generation MCP Server - Claude Desktop Integration
 * Claude generates complete React/Remotion code - MCP server executes it
 * NO TEMPLATES - Pure AI-powered code generation and execution
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration - Standardized to 6970/6971 ports
const APP_ROOT = process.env.DOCKER_CONTAINER === 'true' ? '/app' : path.resolve(__dirname, '../..');
const EXPORTS_DIR = process.env.DOCKER_CONTAINER === 'true' ? '/workspace/out' : path.join(APP_ROOT, 'exports');
const SRC_DIR = process.env.DOCKER_CONTAINER === 'true' ? '/workspace/src' : path.join(APP_ROOT, 'src');
const STUDIO_PORT = parseInt(process.env.REMOTION_STUDIO_PORT || '6970');

// Safe stderr-only logging (no stdout pollution for STDIO)
const log = (level: string, message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  console.error(`[${timestamp}] [CLEAN-STDIO] ${message}`);
  if (data) {
    console.error(JSON.stringify(data, null, 2));
  }
};

class TrueAiStdioMcpServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: 'clean-cut-mcp',
        version: '2.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  private setupErrorHandling(): void {
    this.server.onerror = (error) => {
      log('error', 'MCP Server error', { error: error.message });
    };

    process.on('SIGINT', async () => {
      log('info', 'Shutting down gracefully...');
      await this.server.close();
      process.exit(0);
    });
  }

  private setupToolHandlers(): void {
    // TRUE AI TOOLS: Claude generates code - MCP server executes it
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'create_animation',
            description: 'Execute Claude-generated React/Remotion animation code - creates component file',
            inputSchema: {
              type: 'object',
              properties: {
                code: {
                  type: 'string',
                  description: 'Complete React/Remotion TypeScript code generated by Claude'
                },
                componentName: {
                  type: 'string',
                  description: 'React component name (e.g. "RisingSun", "ParticleSystem")'
                },
                duration: {
                  type: 'number',
                  default: 8,
                  description: 'Animation duration in seconds'
                }
              },
              required: ['code', 'componentName']
            }
          },
          {
            name: 'update_composition',
            description: 'Register new animation component in Remotion Root.tsx',
            inputSchema: {
              type: 'object',
              properties: {
                componentName: {
                  type: 'string',
                  description: 'Component name to register'
                },
                duration: {
                  type: 'number',
                  description: 'Duration in seconds'
                }
              },
              required: ['componentName', 'duration']
            }
          },
          {
            name: 'get_studio_url',
            description: 'Get the URL for Remotion Studio interface',
            inputSchema: {
              type: 'object',
              properties: {},
              additionalProperties: false
            }
          },
          {
            name: 'get_export_directory',
            description: 'Get information about persistent video export directory',
            inputSchema: {
              type: 'object',
              properties: {},
              additionalProperties: false
            }
          }
        ]
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        if (name === 'create_animation') {
          return await this.handleCreateAnimation(args);
        } else if (name === 'update_composition') {
          return await this.handleUpdateComposition(args);
        } else if (name === 'get_studio_url') {
          return await this.handleGetStudioUrl();
        } else if (name === 'get_export_directory') {
          return await this.handleGetExportDirectory();
        } else {
          throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        log('error', `Tool ${name} failed`, { error: error.message });
        return {
          content: [{
            type: 'text',
            text: `[ERROR] ${name} failed: ${error instanceof Error ? error.message : String(error)}`
          }],
          isError: true
        };
      }
    });
  }

  private async handleCreateAnimation(args: any) {
    const { code, componentName, duration = 8 } = args || {};

    log('info', 'Executing Claude-generated animation code', { componentName, duration });

    // Validate required parameters
    if (!code) {
      return {
        content: [{
          type: 'text',
          text: '[ERROR] code is required - Claude must provide complete React/Remotion code'
        }],
        isError: true
      };
    }
    
    if (!componentName) {
      return {
        content: [{
          type: 'text',
          text: '[ERROR] componentName is required - provide React component name'
        }],
        isError: true
      };
    }

    // Ensure directories exist
    await fs.mkdir(EXPORTS_DIR, { recursive: true });
    await fs.mkdir(SRC_DIR, { recursive: true });

    // Validate component name format
    const validComponentName = componentName.charAt(0).toUpperCase() + componentName.slice(1);
    const componentPath = path.join(SRC_DIR, `${validComponentName}.tsx`);
    
    // COLLISION DETECTION: Check if component already exists
    const componentExists = await fs.access(componentPath).then(() => true).catch(() => false);
    if (componentExists) {
      log('warn', `Component ${validComponentName} already exists - overwriting`, { componentPath });
    }
    
    // Write Claude's generated code with export pattern fix for Remotion compatibility
    // CRITICAL FIX: Convert 'export default ComponentName' to 'export { ComponentName }' 
    const fixedCode = code.replace(
      new RegExp(`export\\s+default\\s+${validComponentName}\\s*;?`, 'g'),
      `export { ${validComponentName} };`
    );
    await fs.writeFile(componentPath, fixedCode);
    log('info', `Created animation file with Claude's code: ${componentPath}`);

    const overwriteWarning = componentExists ? `\\n[WARNING] Overwrote existing ${validComponentName} component` : '';
    
    return {
      content: [{
        type: 'text',
        text: `[ANIMATION CREATED] ${validComponentName}\\n\\n` +
              `[FILE] ${validComponentName}.tsx\\n` +
              `[DURATION] ${duration} seconds\\n` +
              `[STUDIO] Ready at http://localhost:${STUDIO_PORT}${overwriteWarning}\\n\\n` +
              `[SUCCESS] Claude's animation code executed successfully!`
      }]
    };
  }

  private async handleUpdateComposition(args: any) {
    const { componentName, duration = 8 } = args || {};

    log('info', 'Registering component in Root.tsx', { componentName, duration });

    if (!componentName) {
      return {
        content: [{
          type: 'text',
          text: '[ERROR] componentName is required'
        }],
        isError: true
      };
    }

    const validComponentName = componentName.charAt(0).toUpperCase() + componentName.slice(1);
    
    try {
      await this.updateRootTsx(validComponentName, duration);
      log('info', `Registered ${validComponentName} in Root.tsx`);
      
      return {
        content: [{
          type: 'text',
          text: `[COMPOSITION UPDATED] ${validComponentName}\\n\\n` +
                `[REGISTERED] Component added to Remotion Root.tsx\\n` +
                `[DURATION] ${duration} seconds\\n` +
                `[STUDIO] Available at http://localhost:${STUDIO_PORT}\\n\\n` +
                `[SUCCESS] Animation ready for preview!`
        }]
      };
    } catch (error) {
      log('error', 'Failed to update composition', error);
      return {
        content: [{
          type: 'text',
          text: `[ERROR] Failed to update composition: ${error instanceof Error ? error.message : String(error)}`
        }],
        isError: true
      };
    }
  }

  private async handleGetStudioUrl() {
    return {
      content: [{
        type: 'text',
        text: `[STUDIO] Remotion Studio is available at:\\n\\nhttp://localhost:${STUDIO_PORT}\\n\\nOpen this URL in your browser to access the visual editor for your animations.`
      }]
    };
  }
  
  private async handleGetExportDirectory() {
    const isDocker = process.env.DOCKER_CONTAINER === 'true';
    
    if (isDocker) {
      return {
        content: [{
          type: 'text',
          text: `[EXPORT DIRECTORY] Videos exported from Remotion Studio appear in:\\n\\n` +
                `Host Path: ./clean-cut-exports\\n` +
                `Container Path: /workspace/out\\n\\n` +
                `[HOW IT WORKS]\\n` +
                `- Export from Remotion Studio (http://localhost:${STUDIO_PORT})\\n` +
                `- Videos automatically appear in ./clean-cut-exports\\n` +
                `- Persistent storage across container restarts\\n` +
                `- Cross-platform (Windows, macOS, Linux)\\n\\n` +
                `[SUCCESS] Persistent video storage active!`
        }]
      };
    } else {
      return {
        content: [{
          type: 'text',
          text: `[EXPORT DIRECTORY] Videos are saved to:\\n\\n${EXPORTS_DIR}\\n\\n` +
                `Export from Remotion Studio and files will appear in the above directory.`
        }]
      };
    }
  }

  // REMOVED: All template fraud code - Claude Desktop generates ALL animation code using TRUE AI

  // Update Root.tsx to register the new animation
  private async updateRootTsx(componentName: string, duration: number): Promise<void> {
    const rootPath = path.join(SRC_DIR, 'Root.tsx');
    const durationFrames = Math.floor(duration * 30);
    
    try {
      let rootContent = '';
      
      // Check if Root.tsx exists
      const rootExists = await fs.access(rootPath).then(() => true).catch(() => false);
      
      if (!rootExists) {
        // Create new Root.tsx
        rootContent = `import { Composition } from 'remotion';
import { ${componentName} } from './${componentName}';

export const RemotionRoot: React.FC = () => {
  return (
    <>
      <Composition
        id="${componentName}"
        component={${componentName}}
        durationInFrames={${durationFrames}}
        fps={30}
        width={1920}
        height={1080}
      />
    </>
  );
};`;
      } else {
        // Read existing Root.tsx and rebuild it properly
        const existingContent = await fs.readFile(rootPath, 'utf8');
        
        // Extract existing imports and compositions
        const importLines: string[] = [];
        const compositions: Array<{id: string, component: string, duration: number}> = [];
        
        const lines = existingContent.split('\n');
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith('import { ') && trimmed.includes("} from './") && !trimmed.includes('./Composition')) {
            // Extract component name from import (exclude the base Composition)
            const match = trimmed.match(/import { (\\w+) } from/);
            if (match) {
              importLines.push(trimmed);
            }
          } else if (trimmed.includes('id="') && !trimmed.includes('id="Main"')) {
            // Extract composition info
            const idMatch = trimmed.match(/id="(\\w+)"/);
            const componentMatch = trimmed.match(/component={(\\w+)}/);
            const durationMatch = trimmed.match(/durationInFrames={(\\d+)}/);
            if (idMatch && componentMatch && durationMatch) {
              compositions.push({
                id: idMatch[1],
                component: componentMatch[1],
                duration: parseInt(durationMatch[1])
              });
            }
          }
        }
        
        // Add new component if not already present
        const importStatement = `import { ${componentName} } from './${componentName}';`;
        if (!importLines.includes(importStatement)) {
          importLines.push(importStatement);
        }
        
        // Add new composition if not already present
        if (!compositions.find(comp => comp.id === componentName)) {
          compositions.push({
            id: componentName,
            component: componentName,
            duration: durationFrames
          });
        }
        
        // Rebuild Root.tsx with proper structure
        rootContent = `import { Composition } from 'remotion';
import { Comp } from './Composition';
${importLines.join('\\n')}

export const RemotionRoot: React.FC = () => {
  return (
    <>
      <Composition
        id="Main"
        component={Comp}
        durationInFrames={90}
        fps={30}
        width={1920}
        height={1080}
      />
${compositions.map(comp => `      <Composition
        id="${comp.id}"
        component={${comp.component}}
        durationInFrames={${comp.duration}}
        fps={30}
        width={1920}
        height={1080}
      />`).join('\\n')}
    </>
  );
};`;
      }
      
      await fs.writeFile(rootPath, rootContent);
      log('info', `Updated Root.tsx with ${componentName}`);
    } catch (error) {
      log('error', 'Failed to update Root.tsx', { error: error.message });
      throw error;
    }
  }

  async run(): Promise<void> {
    log('info', 'Starting TRUE AI STDIO MCP Server');
    log('info', `App Root: ${APP_ROOT}`);
    log('info', `Exports Directory: ${EXPORTS_DIR}`);
    log('info', `Source Directory: ${SRC_DIR}`);
    log('info', `Studio Port: ${STUDIO_PORT}`);
    
    // Ensure directories exist
    await fs.mkdir(EXPORTS_DIR, { recursive: true });
    await fs.mkdir(SRC_DIR, { recursive: true });

    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    
    log('info', 'TRUE AI STDIO MCP Server connected and ready!');
    log('info', 'Available tools: create_animation, update_composition, get_studio_url, get_export_directory');
    log('info', 'Claude Desktop can now generate ANY animation using TRUE AI!');
  }
}

// Start the TRUE AI server
const server = new TrueAiStdioMcpServer();
server.run().catch((error) => {
  console.error('Failed to start TRUE AI STDIO MCP Server:', error);
  process.exit(1);
});